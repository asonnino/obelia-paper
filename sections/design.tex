\section{The \sysname Design} \label{sec:design}

We present the design of \sysname and argue its properties defined in \Cref{sec:goals}.

\subsection{DAG-based consensus protocols} \label{sec:dag}

DAG-based consensus protocols operate in logical \emph{rounds}. In each round, every honest (core) validator creates a unique signed vertex. Byzantine validators may attempt to equivocate by producing conflicting vertices~\cite{dag-rider} or may abstain altogether. During each round, validators collect user transactions and vertices from other validators to construct their next vertex. Each vertex must reference a minimum number of vertices from the previous round (typically $2f + 1$~\cite{narwhal,bullshark,mysticeti}) and adds fresh transactions that do not appear in preceding vertices.

\Cref{alg:core-validator} outlines the operations of these validators, aligning with nearly all existing structured DAG-based consensus protocols~\cite{narwhal,bullshark,shoal,shoal++,mysticeti,dag-rider,dumbo-ng,dispersedledger,sailfish,bbca-chain,fino,gradeddag,cordial-miners,wahoo,lightdag,dai2024remora} and all DAG-based systems that have been deployed in production environments~\cite{narwhal,bullshark,mysticeti,hammerhead}.

When a core validator receives a new vertex $v$, it invokes $\Call{ProcessCoreVertex}{v}$ (Line~\ref{alg:line:process-core-vertex}). The validator first downloads $v$'s causal history (Line~\ref{alg:line:sync-core-ancestors}) and verifies $v$ for validity (Line~\ref{alg:line:valid-core-vertex}), which typically involves checking signatures, validating parent vertex references, and ensuring syntactical correctness. A valid $v$ is then added to the local DAG view of the validator (Line~\ref{alg:line:add-to-dag}).

Next, the validator checks if the new vertex triggers any commits. It derives a set of \emph{leader} vertices either deterministically (in partially synchronous protocols~\cite{bullshark,shoal,mysticeti}) or by reconstructing a global perfect coin~\cite{abraham2023bingo} (in asynchronous protocols~\cite{narwhal,cordial-miners}). Using a protocol-specific decision rule, it analyzes DAG patterns to establish a total order among the leaders (Line~\ref{alg:line:commit-leaders}). If this yields a non-empty sequence, the validator linearizes the DAG into a sequence of vertices $C$ that it outputs to the application layer (Line~\ref{alg:line:linearize}). This linearization step uses a deterministic function like depth-first search over the sub-DAG defined by each leader in the sequence~\cite{dag-rider,narwhal,bullshark}.

To advance the round, the validator attempts to create a new vertex $v'$ through $\Call{TryAdvance}{\;}$ (Line~\ref{alg:line:try-advance}). This succeeds if the validator possesses enough vertices from the previous round and, in partially synchronous protocols, enough leader vertices or if a timeout has occurred. If successful, the validator adds $v'$ to its local DAG view and broadcasts it to the other validators (Line~\ref{alg:line:add-to-dag-2}). Creating a vertex may involve reliable or consistent broadcasting~\cite{dag-rider,narwhal,bullshark,shoal,shoal++}, a best-effort broadcast~\cite{mysticeti,cordial-miners}, or a hybrid of both~\cite{bbca-chain,gradeddag}.

\input{algorithms/core-validator}
\input{algorithms/auxiliary-validator}

\subsection{vertex creation rule and commit rule} \label{sec:protocol}

We present the protocol for auxiliary validators and the modifications made to the core validator protocol, using \Cref{fig:dag} as an example. We denote vertices using the notation $v(author, round)$, where $author$ represents the validator that authored the vertex and $round$ indicates the round number.

\begin{figure}[t]
    \vskip -1em
    \centering
    \includegraphics[width=0.7\textwidth]{figures/dag}
    \caption{
        Example of \sysname execution with 4 core validators and $t_a = 2$.
    }
    \label{fig:dag}
    \vskip -1em
\end{figure}

\para{Auxiliary validators}
Auxiliary validators operate as full nodes, downloading the DAG generated by core validators while also collecting client transactions. \Cref{alg:auxiliary-validator} illustrates their protocol. Each auxiliary validator composes a signed \emph{proposal} containing client transactions and hash references to at least $2f + 1$ vertices created by core validators for a given round. They then send it to the core validators who check their validity and reply with a counter signature. The auxiliary validator then assembles a vertex, made up of the $2f + 1$ counter-signatures, and rebroadcasts it to all core validators. For example, $v_a(aux_i, R+2)$ references the vertices from round $R+1$ created by core validators $core_2$, $core_3$, and $core_4$. This protocol is essentially an instance of \emph{Byzantine consistent broadcast}~\cite{cachin2011introduction} driven by each individual auxiliary validator.
%
This design choice solves \textbf{challenge 1} by forgoing communication between auxiliary validators and effectively leveraging the core validators as communication layer.

\para{Core validators}
\Cref{alg:core-validator} shows the modifications to the core validator's protocol in \change{orange}. Core validators execute $\Call{ProcessAuxProposal}{p}$ to validate, download the causal history, and counter-sign an auxiliary validator's proposal $p$. Since $p$ references $2f + 1$ core validator vertices, this verification allows core validators to synchronize any potentially missing vertices from the author of $p$. This protocol incentivizes auxiliary validators to collaborate, as inclusion of their vertices in the final commit sequence grants them a share of vertex rewards~\cite{ethereum}. The function $\Call{ProcessAuxVertices}{v_a}$ shows how core validators process a vertex $v_a$ (that is, a proposal $p$ counter-signed by $2f + 1$ core validators). Core validators add this vertex to a new map, $\dag_a$, which will later be merged into the DAG $\dag_c$ operated by core validators.
%
This design choice solves \textbf{challenge 2} by ensuring that malicious or unreliable auxiliary validators cannot affect the protocol once they delivered their vertex to a core validator. Since a correctly signed auxiliary vertex indicates that at least $2f + 1$ core validators possess its data and causal history, the proposed data from auxiliary validators remains highly available despite their potential unreliability.

Next, we modify the vertex creation rules: every fixed number of rounds, the core validator leader(s) (e.g., $L_3$ in \Cref{fig:dag}) must reference vertices from auxiliary validators with a joint stake totaling at least $t_a$ (see \Cref{sec:model}). In the figure, $L_3$ references $v_a(aux_i, R+2)$ and $v_a(aux_k, R)$.
%
This design solves \textbf{challenge 3} by allowing auxiliary validators to participate in the consensus without slowing it down. It ensures that auxiliary validators can asynchronously create vertices at a slower pace than core validators, without impacting the critical path, while still maintaining minimal required participation.

Auxiliary vertices are essentially treated as \emph{weak links}~\cite{dag-rider}, with core validators required to download them before processing a vertex. Auxiliary vertices are not used to establish the order of committed leaders but are included during the linearization step (Line~\ref{alg:line:linearize}). Designing \sysname to operate only at the linearization layer makes it compatible with nearly all DAG-based protocols: while leader ordering algorithms vary across protocols, linearization is a common procedure. The validator linearizes the vertices within the sub-DAG defined by each leader vertex through any deterministic procedure, such as a depth-first search~\cite{dag-rider}. If a vertex has already been linearized by a previous leader, the validator omits. Each leader is processed sequentially, ensuring all vertices appear in the final commit sequence in a deterministic order based on their causal dependencies.

In the example shown in \Cref{fig:dag}, the sequence of committed leaders (output from \Cref{alg:line:commit-leaders}) is ([$L_1$, $L_2$, $L_3$]).
$L_{1}$ does not define any sub-DAG (the process begins at round $R$), so only $L_1$ is added to the commit sequence.
$L_{2}$ defines a sub-DAG of the green vertices, which are linearly ordered, as e.g., $v_c(core_1,R+1)$, $v_c(core_2,R)$, $v_c(core3,R)$, $v_c(core_2,R+1)$, $v_c(core_3,R+1)$, and $L_2$.
While processing $L_3$, which defines the sub-DAG of both blue and orange vertices, the validator collects and linearizes all such vertices. As a result, although the original DAG might have excluded the core orange vertices ($v_c(core_4, R)$ and $v_c(core_4, R+1)$) and would have omitted the auxiliary vertices ($v_a(aux_i,R+2)$ and $v_a(aux_k,R)$), \sysname guarantees their inclusion in the final commit sequence. This inclusion helps core validator $core_3$ to synchronize parts of the DAG that were potential missing from its local view.

\subsection{Security analysis} \label{sec:security}
\Cref{alg:core-validator} shows that \sysname intervenes only at Line~\ref{alg:line:sync-aux-ancestors} (to sync ancestors auxiliary vertices), at Line~\ref{alg:line:linearize} (the linearization layer), and Line~\ref{alg:line:try-new-core-vertex} (when proposing a new vertex), leaving the leader selection and the commit rule untouched.

This design choice ensures that \sysname is safe provided that the DAG linearization procedure is deterministic, as is the case in existing DAG-based protocols (which typically use a depth-first search~\cite{dag-rider}). This also implies that safety holds regardless of the number of honest auxiliary validators.

It also ensures that we can show that \sysname is live under the same network model as the underlying protocol by ensuring that (1) the core validator can eventually synchronize missing auxiliary vertices (Line~\ref{alg:line:sync-aux-ancestors}), (2) the DAG linearization procedure eventually terminates (Line~\ref{alg:line:linearize}), and (3) the core validator can eventually create a new vertex (Line~\ref{alg:line:try-new-core-vertex}).

Point (1) is easy to show since core validators only reference auxiliary vertices once it is certified, which ensures that at least $f+1$ honest core validators also hold the vertex~\cite{cachin2011introduction}. Point (2) is satisfied since auxiliary vertices are threated as linearized as core vertices. For Point (3) we note that as long as $t_a$ auxiliary validators are honest, at least $2f+1$ core validators successfully call $\Call{ProcessAuxProposal}{\cdot}$ (Line~\ref{alg:line:process-aux-proposal}) and $\Call{ProcessAuxVertex}{\cdot}$ (Line~\ref{alg:line:process-aux-vertex}), which ensure they update their local DAG $\dag_a$ with new auxiliary vertices. This guarantees that the core validator can eventually obtain enough auxiliary vertices to create a new core vertex.